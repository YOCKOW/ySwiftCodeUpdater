/* *************************************************************************************************
 CodeUpdater.swift
  Â© 2019 YOCKOW.
    Licensed under MIT License.
    See "LICENSE.txt" for more information.
************************************************************************************************ */

import Foundation
import NetworkGear
import TemporaryFile
import yExtensions

private let _HEADER = """
//# DO NOT MODIFY.
//# This is autogenerated by `ySwiftCodeUpdater`(https://github.com/YOCKOW/ySwiftCodeUpdater).
//# Please see documents in this project to learn how to regenerate.
//# The material(s) to generate this file was/were obtained from below:

""".data(using: .utf8)!


private func _mustBeOverridden(function: StaticString = #function,
                               file: StaticString = #file, line: UInt = #line) -> Never {
  fatalError("\(function) must be overridden.", file: file, line: line)
}

public final class CodeUpdater {
  private struct _Delegate {
    private class _Box {
      var identifier: String { _mustBeOverridden() }
      var sourceURLs: Array<URL> { _mustBeOverridden() }
      var destinationURL: URL { _mustBeOverridden() }
      func outrightConvert<S>(sourceURLs: S) -> Data where S: Sequence, S.Element == URL { _mustBeOverridden() }
    }
    private class _SomeDelegate<D, T>: _Box where D: CodeUpdaterDelegate, D.IntermediateDataType == T {
      private var _base: D
      fileprivate init(_ base: D) { self._base = base }
      
      override var identifier: String { return self._base.identifier }
      override var sourceURLs: Array<URL> { return self._base.sourceURLs }
      override var destinationURL: URL { return self._base.destinationURL }
      override func outrightConvert<S>(sourceURLs: S) -> Data where S: Sequence, S.Element == URL {
        var interms: Array<IntermediateDataContainer<T>> = []
        _do("Prepare data conversion.") {
          for url in sourceURLs {
            var interm = try self._base.prepare(sourceURL: url)
            interm.sourceURL = url
            interms.append(interm)
          }
        }
        return _do("Convert the intermediate data.") { () throws -> Data in
          return try self._base.convert(interms)
        }
      }
    }
    
    private var _box: _Box
    fileprivate var identifier: String { return self._box.identifier }
    fileprivate var sourceURLs: Array<URL> { return self._box.sourceURLs }
    fileprivate var destinationURL: URL { return self._box.destinationURL }
    fileprivate func outrightConvert() -> Data {
      return self._box.outrightConvert(sourceURLs: self.sourceURLs)
    }
    
    fileprivate init<D>(_ delegate: D) where D: CodeUpdaterDelegate {
      self._box = _SomeDelegate(delegate)
    }
  }
  
  private var _delegate: _Delegate
  public var identifier: String { return self._delegate.identifier }
  public var sourceURLs: Array<URL> { return self._delegate.sourceURLs }
  public var destinationURL: URL { return self._delegate.destinationURL }
  
  public var forcesToUpdate: Bool = false
  
  private var _convertedData: Data? = nil
  public func convertedData() -> Data {
    if self._convertedData == nil {
      _viewInfo("\(self.identifier): Start data conversion.")
      self._convertedData = self._delegate.outrightConvert()
    }
    return self._convertedData!
  }
  
  public init<D>(delegate: D) where D: CodeUpdaterDelegate {
    precondition(delegate.destinationURL.isFileURL, "Destination must be local.")
    self._delegate = _Delegate(delegate)
  }
  
  public func shouldUpdate() throws -> Bool {
    if !FileManager.default.fileExists(atPath: self._delegate.destinationURL.path) {
      return true
    }

    let info = try _TargetFileInfo(fileAt: self._delegate.destinationURL)
    for sourceURL in self._delegate.sourceURLs {
      if !info.containsInfo(for: sourceURL) { return true }
      switch (info.lastModifiedDate(for: sourceURL), info.eTag(for: sourceURL)) {
      case (nil, nil):
        return true
      case (let dest_lastModified?, nil):
        guard let source_lastModified = _lastModified(of: sourceURL) else { return true }
        if dest_lastModified < source_lastModified { return true }
      case (nil, let dest_ETag?):
        guard let source_ETag = _eTag(of: sourceURL) else { return true }
        if !(dest_ETag =~ source_ETag) { return true }
      case (let dest_lastModified?, let dest_ETag?):
        guard
          let source_lastModified = _lastModified(of: sourceURL),
          let source_ETag = _eTag(of: sourceURL)
          else {
            return true
        }
        if dest_lastModified < source_lastModified || !(dest_ETag =~ source_ETag) { return true }
      }
    }
    return false
  }

  public func update() {
    let destURL = self._delegate.destinationURL
    let destPath = destURL.path
    _do("Update file at \(destPath)") {
      if try !self.forcesToUpdate && !self.shouldUpdate() {
        _viewInfo("File at \(destPath) is already up-to-date.")
        return
      }
      let data = convertedData()
      
      var temporaryFile = try TemporaryFile()
      defer { try? temporaryFile.close() }
      _do("Write the data to temporary file.") {
        try temporaryFile.write(contentsOf: _HEADER)
        for url in self._delegate.sourceURLs {
          try temporaryFile.write(string: "//\n")
          try temporaryFile.write(string: "// URL: \(url.absoluteURL)\n")
          if let lastModified = _lastModified(of: url) {
            try temporaryFile.write(string: "// Last-Modified: \(lastModified.iso8601String)\n")
          }
          if let eTag = _eTag(of: url) {
            try temporaryFile.write(string: "// ETag: \(eTag.description)\n")
          }
        }
        temporaryFile.write("\n")
        try temporaryFile.write(contentsOf: data)
      }
      
      let backupURL = destURL.appendingPathExtension("old")
      _do("Copy the temporary file to the destination.") {
        if destURL.isExistingLocalFile {
          try FileManager.default.moveItem(at: destURL, to: backupURL)
        }
        try temporaryFile.copy(to: destURL)
        if backupURL.isExistingLocalFile {
          try FileManager.default.removeItem(at: backupURL)
        }
      }
    }
  }
}
